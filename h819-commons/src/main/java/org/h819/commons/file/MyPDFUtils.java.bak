package org.h819.commons.file;


import com.itextpdf.io.font.FontConstants;
import com.itextpdf.io.font.FontProgramFactory;
import com.itextpdf.io.image.ImageData;
import com.itextpdf.io.image.ImageDataFactory;
import com.itextpdf.io.source.FileChannelRandomAccessSource;
import com.itextpdf.io.source.RandomAccessFileOrArray;
import com.itextpdf.kernel.font.PdfFont;
import com.itextpdf.kernel.font.PdfFontFactory;
import com.itextpdf.kernel.geom.Rectangle;
import com.itextpdf.kernel.pdf.PdfDocument;
import com.itextpdf.kernel.pdf.PdfReader;
import com.itextpdf.kernel.pdf.PdfWriter;
import com.itextpdf.kernel.pdf.canvas.PdfCanvas;
import com.itextpdf.kernel.pdf.extgstate.PdfExtGState;
import com.itextpdf.layout.Document;
import com.itextpdf.layout.element.Paragraph;
import com.itextpdf.layout.property.TextAlignment;
import com.itextpdf.layout.property.VerticalAlignment;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.h819.commons.MyConstants;
import org.h819.commons.MyExecUtils;
import org.h819.commons.exe.ExecParameter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @author H819
 * @version V1.0
 * @Title: PDFBaseUtils.java
 * @Description: TODO(基础pdf处理类)
 * @date 2015-3-1
 */


public class MyPDFUtils {

    // 该变量专门为 countPages() 函数设立，由于使用了递归，故提到全局变量，否则每次的返回值不能累计
    // private static StringBuffer encryptPdfNamesTemp;
    private static List<String> tempList = new ArrayList<>();

    // 该变量专门为 countPages() 函数设立，由于使用了递归，故提到全局变量，否则每次的返回值不能累计
    private static int numberOfPagesOfDirectory;

    private static Logger logger = LoggerFactory.getLogger(MyPDFUtils.class);



    /**
     * 静态调用
     */
    private MyPDFUtils() {

    }


    /**
     * 压缩已经存在的 pdf 文件。实例了处理已经存在的文件的方法
     *
     * @param srcPdfFile  the original PDF
     * @param descPdfFile the resulting PDF
     * @throws java.io.IOException
     * @throws DocumentException
     */
    public static void compressPdf(File srcPdfFile, File descPdfFile) throws IOException, DocumentException {

        if (srcPdfFile == null || !srcPdfFile.exists())
            throw new IOException("src pdf file '" + srcPdfFile
                    + "' does not exsit.");

        PdfReader reader = getPdfReader(srcPdfFile);
        PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(
                descPdfFile.getAbsoluteFile()), PdfWriter.VERSION_1_7);

        stamper.getWriter().setCompressionLevel(9);
        int total = reader.getNumberOfPages() + 1;
        for (int i = 1; i < total; i++) {
            reader.setPageContent(i, reader.getPageContent(i));
        }
        stamper.setFullCompression();
        stamper.close();
        reader.close();
    }

    /**
     * 通过压缩 pdf 文件中图片的方式，压缩 pdf
     *
     * @param srcPdf      the original PDF
     * @param destPdf     the resulting PDF
     * @param imageFactor The multiplication factor for the image (图片缩小比例 ，例如 imageFacto =0.5f)
     * @throws IOException
     * @throws DocumentException
     */
    public static void compressPdf(File srcPdf, File destPdf, float imageFactor) throws IOException, DocumentException {

        PdfReader reader = new PdfReader(srcPdf.getAbsolutePath());
        int n = reader.getXrefSize();
        PdfObject object;
        PRStream stream;
        // Look for image and manipulate image stream
        for (int i = 0; i < n; i++) {
            object = reader.getPdfObject(i);
            if (object == null || !object.isStream())
                continue;
            stream = (PRStream) object;
            if (!PdfName.IMAGE.equals(stream.getAsName(PdfName.SUBTYPE)))
                continue;
            if (!PdfName.DCTDECODE.equals(stream.getAsName(PdfName.FILTER)))
                continue;
            PdfImageObject image = new PdfImageObject(stream);
            BufferedImage bi = image.getBufferedImage();
            if (bi == null)
                continue;
            int width = (int) (bi.getWidth() * imageFactor);
            int height = (int) (bi.getHeight() * imageFactor);
            if (width <= 0 || height <= 0)
                continue;
            BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
            AffineTransform at = AffineTransform.getScaleInstance(imageFactor, imageFactor);
            Graphics2D g = img.createGraphics();
            g.drawRenderedImage(bi, at);
            ByteArrayOutputStream imgBytes = new ByteArrayOutputStream();
            ImageIO.write(img, "JPG", imgBytes);
            stream.clear();
            stream.setData(imgBytes.toByteArray(), false, PRStream.NO_COMPRESSION);
            stream.put(PdfName.TYPE, PdfName.XOBJECT);
            stream.put(PdfName.SUBTYPE, PdfName.IMAGE);
            stream.put(PdfName.FILTER, PdfName.DCTDECODE);
            stream.put(PdfName.WIDTH, new PdfNumber(width));
            stream.put(PdfName.HEIGHT, new PdfNumber(height));
            stream.put(PdfName.BITSPERCOMPONENT, new PdfNumber(8));
            stream.put(PdfName.COLORSPACE, PdfName.DEVICERGB);
        }
        reader.removeUnusedObjects();
        // Save altered PDF
        PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(destPdf.getAbsolutePath()));
        stamper.setFullCompression();
        stamper.close();
        reader.close();
    }

    /**
     * 创建一个不压缩的pdf
     *
     * @param srcPdfFile  the original PDF
     * @param descPdfFile the resulting PDF
     * @throws java.io.IOException
     * @throws DocumentException
     */
    public static void decompressPdf(File srcPdfFile, File descPdfFile)
            throws IOException, DocumentException {

        if (srcPdfFile == null || !srcPdfFile.exists())
            throw new IOException("src pdf file '" + srcPdfFile
                    + "' does not exsit.");

        PdfReader reader = getPdfReader(srcPdfFile);
        PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(descPdfFile.getAbsoluteFile()));
        stamper.getWriter().setCompressionLevel(PdfStream.NO_COMPRESSION);
        int total = reader.getNumberOfPages() + 1;
        for (int i = 1; i < total; i++) {
            reader.setPageContent(i, reader.getPageContent(i));
        }
        stamper.close();
        reader.close();

    }

    /**
     * 通过第三方提供的工具，破解没有设置打开密码的 pdf 文件。可以递归破解指定文件夹内的所有文件，并保留原来的目录结构
     *
     * @param srcPdfFileDirectory  存放待破解 pdf 文件的文件夹. 破解之后的文件，存放子默认的文件夹内。
     * @param descPdfFileDirectory 破解之后的文件存放的文件夹，保持和源文件同样的结构
     * @param badDirectory         存放有打开密码，不能破解的 pdf 的文件夹。
     * @throws java.io.IOException
     */
    public static void decryptDirectory(File srcPdfFileDirectory, File descPdfFileDirectory, File badDirectory) throws IOException {

        if (!isEnoughSpace(srcPdfFileDirectory, descPdfFileDirectory))
            throw new IOException("目标文件夹磁盘控件不够");

        for (File file : srcPdfFileDirectory.listFiles()) {
            String path = descPdfFileDirectory.getAbsolutePath() + File.separator + file.getName();
            if (file.isFile()) {
                decryptFile(file, Paths.get(path).toFile(), badDirectory);
            } else if (file.isDirectory())
                decryptDirectory(file, Paths.get(path).toFile(), badDirectory);
            else return;

        }
    }

    /**
     * 通过第三方提供的工具，破解没有设置打开密码的 pdf 文件。
     * windows 下使用
     * "PDF Password Remover v4.0" 软件提供命令行破解，通过系统调用该命令行，进行破解
     *
     * @param srcPdf        存放待破解 pdf 文件
     * @param descPdf       存放破解之后的 pdf 文件
     * @param ownerPassword 用户打开文件密码。如果设置了打开密码，需要此参数，否则不能解密
     * @param badDirectory  存放有打开密码，不能破解的 pdf 的文件夹。
     * @throws java.io.IOException
     */
    public static void decryptFile(File srcPdf, File descPdf, String ownerPassword, File badDirectory) throws IOException {

        String extension = FilenameUtils.getExtension(srcPdf.getAbsolutePath());

        if (!extension.equalsIgnoreCase("pdf"))
            return;

        // 损坏的 0 字节文件，直接拷贝到统一的文件夹
        if (FileUtils.sizeOf(srcPdf) == 0) {
            logger.info("{} size =0 ,copy to {}", srcPdf.getAbsoluteFile(), badDirectory.getAbsoluteFile());
            FileUtils.copyDirectory(srcPdf, badDirectory, true);
            return;
        }

        try {

            PdfReader reader;
            if (ownerPassword != null)
                reader = getPdfReader(srcPdf, ownerPassword);
            else
                reader = getPdfReader(srcPdf);

            if (!reader.isEncrypted()) {// 未加密的文件，直接拷贝
                FileUtils.copyFile(srcPdf, descPdf);
                logger.info("not encrypted,copy {} to {} ", srcPdf.getAbsolutePath(), descPdf.getAbsoluteFile());
                return;
            }


            List<ExecParameter> list = new ArrayList(2);
            list.add(new ExecParameter("-i", srcPdf.getAbsolutePath())); // 只有 key ，没有 value
            list.add(new ExecParameter("-o", descPdf.getAbsolutePath()));
//            list.add(new ExecParameter("-u", ""));
//            list.add(new ExecParameter("-w", ""));
            MyExecUtils.exec(Paths.get(getPdfPdfdecryptExec()), list, 1);
            logger.info("decrypted {} to {}", srcPdf.getAbsolutePath(), descPdf.getAbsolutePath());
            // 关闭处理完成的文件
            reader.close();

        } catch (BadPasswordException e) {
            // 有打开密码的文件，不能破解，统一拷贝至一个文件夹。
            logger.info("{} has user password ,copy to {}", srcPdf.getAbsoluteFile(), badDirectory.getAbsoluteFile());
            FileUtils.copyFileToDirectory(srcPdf, badDirectory, true);
            e.printStackTrace();
            return;
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    /**
     * 破解没有用户打开密码的文件
     *
     * @param srcPdf       存放待破解 pdf 文件
     * @param descPdf      存放破解之后的 pdf 文件
     * @param badDirectory 存放有打开密码，不能破解的 pdf 的文件夹。
     * @throws java.io.IOException
     */
    public static void decryptFile(File srcPdf, File descPdf, File badDirectory) throws IOException {
        decryptFile(srcPdf, descPdf, null, badDirectory);
    }




    /**
     * http://www.javabeat.net/javascript-in-pdf-documents-using-itext/
     * http://www.javabeat.net/javascript-communication-between-html-and-pdf-in-itext/
     * 去除附在 PDF 属性 field 上的 javaScript
     * <p>
     * pdf 文件可以添加 javaScript，来实现某种功能，例如激发对话框等动作。
     * <p>
     * javaScript 可以附加于某个 filed，此时去掉 这个 filed，使 javaScript 代码因缺少变量而无法执行
     * <p>
     * 即可以达到去除 javaScript 的目的。
     * <p>
     * 通过 itext 的 reader.getJavaScript()方法，可以查看 pdf 文件 JavaScript源代码(adobe pro
     * 控制台也可以看到源码)
     * <p>
     * 通过源代码可以得到具体的 field 名称
     *
     * @param srcPdfFileDir   源文件夹
     * @param descPdfFileDir  目标文件夹
     * @param removeFieldName 有 javaScript 限制的字段名称
     * @throws java.io.IOException
     */
    public static void removeFieldJavaScript(File srcPdfFileDir,
                                             File descPdfFileDir, String removeFieldName) throws IOException {

        if (!srcPdfFileDir.isDirectory()) {
            logger.info("srcPdfFileDir is not a Directory: "
                    + srcPdfFileDir.getAbsolutePath());
            return;
        }

        File listFiles[] = srcPdfFileDir.listFiles();

        if (listFiles.length == 0) {
            logger.info("srcPdfFileDir has not file. "
                    + srcPdfFileDir.getAbsolutePath());
            return;
        }

        FileUtils.forceMkdir(descPdfFileDir);

        // 检查磁盘空间是否充足

        // 目标盘剩余空间
        long prefixDiskFreeSize = descPdfFileDir.getFreeSpace();
        // 源文件夹大小
        long srcSize = FileUtils.sizeOf(srcPdfFileDir);

        logger.info(descPdfFileDir.getAbsolutePath() + " 目标盘剩余空间："
                + prefixDiskFreeSize / 1000000.00 + " M");
        logger.info(srcPdfFileDir.getAbsolutePath() + " 原文件夹大小 :" + srcSize
                / 1000000.00 + " M");

        if (prefixDiskFreeSize < srcSize) {

            logger.info(FilenameUtils.getPrefix(descPdfFileDir.getAbsolutePath())
                    + " has not enoght disk size .");

            return;
        }

        // logger.info(descPdfFileDir.getAbsolutePath());

        for (File f : listFiles) {
            String fileName = f.getName();
            String extensiion = FilenameUtils.getExtension(fileName)
                    .toLowerCase();

            PdfReader reader = null;

            PdfStamper stamper = null;

            if (f.isFile()) {
                if (extensiion.equals("pdf")) {

                    reader = getPdfReader(f);

                    File fileDesc = new File(descPdfFileDir.getAbsolutePath()
                            + File.separator + fileName);

                    try {
                        stamper = new PdfStamper(reader,
                                FileUtils.openOutputStream(fileDesc));

                        /**
                         * 在无法确定表单名称的时候，都去掉
                         * **/
                        // reader.removeFields();

                        /**
                         * 能确定表单名称，仅去掉附带 javaScript 的表单
                         * **/
                        AcroFields form = stamper.getAcroFields();
                        form.removeField(removeFieldName);

                        stamper.close();
                        reader.close();

                    } catch (DocumentException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

                } else
                    continue;

            }// end if f.isFile

            else if (f.isDirectory()) {
                removeFieldJavaScript(f,
                        new File(descPdfFileDir.getAbsolutePath()
                                + File.separator + fileName), removeFieldName);
            }// end if f.isDirectory
            else
                continue;

        }// end for

        logger.info("finished !");
    }



    /**
     * 分割文件
     * <p/>
     * <p>
     * 源自 iText in Action 2nd Edition，Chapter 6: Working with existing PDFs
     * ，SelectPages
     * </p>
     *
     * @param src       源文件
     * @param desc      目标文件
     * @param beginPage 起始页
     * @param endPage   结束页
     * @throws java.io.IOException
     * @throws DocumentException
     */
    public static void splitToPages(File src, File desc,
                                    int beginPage, int endPage) throws IOException, DocumentException {

        PdfReader reader = getPdfReader(src);
        // reader.selectPages("4-8");
        reader.selectPages(Integer.toString(beginPage) + "-"
                + Integer.toString(endPage));
        PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(
                desc));
        stamper.close();
    }

    /**
     * 检查文件夹内的文件是否被加密，用到了递归方法，返回值被全局变量记录，通过 findEncryptPdf()函数调用
     *
     * @param srcPdfFileDir 待检查的文件夹
     * @throws java.io.IOException
     */
    private static void testEcryptPdf(File srcPdfFileDir) throws IOException {

        if (!srcPdfFileDir.isDirectory()) {
            logger.info("srcPdfFileDir is not a Directory: "
                    + srcPdfFileDir.getAbsolutePath());
            return;
        }

        File listFiles[] = srcPdfFileDir.listFiles();

        if (listFiles.length == 0) {
            logger.info("srcPdfFileDir has not file. "
                    + srcPdfFileDir.getAbsolutePath());
            return;
        }

        // logger.info(descPdfFileDir.getAbsolutePath());

        for (File f : listFiles) {
            String fileName = f.getName();
            String extension = FilenameUtils.getExtension(fileName).toLowerCase();

            if (f.isFile()) {

                if (extension.equals("pdf")) {

                    // 损坏的 0 字节文件，文件体积大于 40 M， 直接登记
                    if (FileUtils.sizeOf(f) == 0) {

                        tempList.add("size ==0 40M :" + f.getAbsolutePath());
                        continue;
                    }

                    PdfReader reader;
                    try {
                        reader = getPdfReader(f);
                    } catch (BadPasswordException e) {
                        // 有打开密码的文件，不能破解，直接登记
                        e.printStackTrace();
                        tempList.add("BadPassword,can not open :" + f.getAbsolutePath());
                        continue;
                    }
                    // logger.info("fileDesc name :" + fileDesc.getAbsolutePath());

                    if (reader.isEncrypted()) {// 未加密的文件，，直接登记
                        tempList.add("encrypted :" + f.getAbsolutePath());
                        reader.close();
                        continue;
                    } else {
                        tempList.add("not encrypted :" + f.getAbsoluteFile());
                        reader.close();
                        continue;
                    }

                }// end if f.isFile
                else
                    continue;
            } else if (f.isDirectory()) {
                testEcryptPdf(f);
            }// end if f.isDirectory
            else
                continue;

        }// end for

    }

    /**
     * 简化代码编写
     *
     * @param srcPdf
     * @param destPdf
     * @return
     * @throws IOException
     * @throws DocumentException
     */

    public static PdfStamper getPdfStamper(File srcPdf, File destPdf) throws IOException, DocumentException {
        return new PdfStamper(getPdfReader(srcPdf), new FileOutputStream(destPdf), PdfWriter.VERSION_1_7);
    }

// http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/js_api_reference.pdf
// adobe 有 javaScript 参考文档



    /**
     * pdfdecrypt.exe 文件路径
     *
     * @return
     * @throws IOException
     */
    private static String getPdfPdfdecryptExec() {

        //命令行模式，只需要两个文件即可
        String exec1 = "/pdfdecrypt.exe";
        String exec2 = "/license.dat";

        String tempPath =
                SystemUtils.getJavaIoTmpDir()
                        + File.separator + MyConstants.JarTempDir + File.separator;

        String exec1Path = tempPath + exec1;
        String exec2Path = tempPath + exec2;

        //如果已经拷贝过，就不用再拷贝了
        if (!Files.exists(Paths.get(exec1Path)))
            MyFileUtils.copyResourceFileFromJarLibToTmpDir(exec1);

        if (!Files.exists(Paths.get(exec2Path)))
            MyFileUtils.copyResourceFileFromJarLibToTmpDir(exec2);


        return exec1Path;
    }

}
